export const metadata = {
  title: "What I Learned About Supabase Auth in Next.js App Router",
  date: "2025-08-28",
  excerpt: "Lessons learned from building Murmuin â€” an emotion-tracking app with Supabase Auth and Next.js App Router.",
  tags: ["next.js", "supabase", "auth", "app router", "rsc"],
  draft: false,  
};

Iâ€™m currently building **Murmuin**, an app that tracks user emotions like a diary and recommends a matching yoga flow routine.  
All logs and routines are stored in Supabase and visualized as a history graph.  

Sounds simple enough â€” until I hit the wall of *â€œwhere do I call Supabase, and which client should I use?â€* ğŸ¤¯

Hereâ€™s what I figured out after a couple of weeks of trial and error.

---

## High-Level Component Map

```bash
flowchart LR
  subgraph Browser [Client (Browser)]
    CC[Client Components\nUI: forms, buttons\nâ†³ supabase.auth.signOut()]
    Nav[Next Router\npush/replace/refresh]
  end

  subgraph AppRouter [Next.js App Router (Server)]
    RSC[Server Components (RSC)\nâ†³ createSupabaseRSC()\nâ†³ auth.getUser() (read-only)]
    SA["Server Actions ('use server')\nâ†³ createSupabaseForRouteOrAction()"]
    RH[Route Handlers /api/*\nâ†³ createSupabaseForRouteOrAction()]
    MW[Middleware\nâ†³ createServerClient(@supabase/ssr)\nâ†³ refresh cookies]
    CB[/callback route\nexchangeCodeForSession(code)]
  end

  subgraph Supabase [Supabase]
    Auth[Auth\n(verify user, issue/rotate cookies)]
    DB[(Postgres)\nRLS enforced]
  end

  CC <--> Nav
  CC -->|fetch /api/*| RH
  CC -->|navigate /callback?code=...| CB
  RSC -->|read| DB
  SA -->|read/write| DB
  RH -->|read/write| DB
  MW -->|refresh| Auth
  CB -->|exchangeCodeForSession| Auth
  RSC -->|getUser()| Auth
  SA -->|getUser()| Auth
  RH -->|getUser()| Auth
```

This map helped me stop guessing.  
It shows **which layer is allowed to talk to Supabase** and what kind of client I should use there.

---

## Auth Lifecycle (Sequence)

```bash
sequenceDiagram
  participant U as User (Browser)
  participant MW as Next Middleware
  participant RSC as RSC / Pages
  participant RH as API Routes / Server Actions
  participant CB as /callback
  participant AUTH as Supabase Auth
  participant DB as Supabase DB (RLS)

  Note over U: User clicks "Sign in" (OAuth)
  U->>AUTH: Provider redirect â†’ Auth
  AUTH-->>U: Redirect to /callback?code=...

  U->>CB: GET /callback?code=...
  CB->>AUTH: exchangeCodeForSession(code)
  AUTH-->>CB: Set session cookies (via res.cookies)
  CB-->>U: Redirect to app (e.g., "/")

  U->>MW: Any request
  MW->>AUTH: auth.getSession() (refresh if needed)
  MW-->>U: Forward with refreshed cookies

  U->>RSC: Server-rendered page
  RSC->>AUTH: auth.getUser() (verified)
  alt user ok
    RSC->>DB: read (RLS: user_id = auth.uid())
  else no user
    RSC-->>U: redirect(/login?redirectTo=...)
  end

  U->>RH: POST /api/... or Server Action
  RH->>AUTH: auth.getUser() (verified)
  RH->>DB: read/write under RLS
  RH-->>U: JSON response

  Note over U: User clicks "Logout"
  U->>AUTH: supabase.auth.signOut() (client)
  U->>MW: Next request â†’ cookies cleared/rotated
```

The key for me:  
- âœ… **Always use `auth.getUser()` on the server.**  
- âŒ Donâ€™t rely on `auth.getSession()` for access control (that one is just for refresh).  

---

## Data Access Patterns

- **RSC / Layouts** â†’ `createSupabaseRSC()` (read-only) + `auth.getUser()` â†’ gate pages & server reads  
- **Server Actions / API Routes** â†’ `createSupabaseForRouteOrAction()` (write-enabled) â†’ safe writes & trusted reads  
- **Middleware** â†’ `createServerClient(@supabase/ssr)` + `auth.getSession()` â†’ refresh cookies, protect routes  
- **Client Components** â†’ `createSupabaseBrowserClient()` (UI only) + `auth.signOut()` â†’ âŒ donâ€™t do access control  

---

## Key Files in My Project

- `src/lib/supabaseServerReadOnly.ts` â†’ `createSupabaseRSC()`  
- `src/lib/supabaseServerWrite.ts` â†’ `createSupabaseForRouteOrAction()`  
- `src/middleware.ts` â†’ SSR cookie refresh & protection  
- `/callback/route.ts` â†’ `exchangeCodeForSession`  
- Everywhere â†’ `auth.getUser()`  

---

## RLS & Table Policies

I turned RLS **ON** for: `users`, `emotion_logs`, `routine_logs`.

```sql
using ( user_id = auth.uid() )
with check ( user_id = auth.uid() )
```

This way, even if I screw up in the frontend, Postgres wonâ€™t let another userâ€™s data slip through.  

---

## Pitfalls I Hit ğŸ˜…

- âŒ Tried calling a write client from RSC/layout â†’ â€œCookies can only be modified from a Server Actionâ€  
- âŒ Tried using `auth.getSession()` on server â†’ always null  
- âŒ Kept some old `/api/auth/set` cookie sync logic â†’ totally unnecessary  
- âŒ Mixed `@supabase/auth-helpers-nextjs` with `@supabase/ssr` â†’ pure chaos  

---

## Whatâ€™s Next

- **Better error handling**: split 401 (redirect to login) vs 403 (show error)  
- **Deployment sanity checks**: verify cookie rotation in Netlify/Vercel prod env  
- **Security audit**: ensure Service Role Key never leaks to client  

---

## Outro

If youâ€™re building with **Supabase + Next.js App Router**, my advice is:  
ğŸ‘‰ draw the map first, then implement.  
It saved me from tons of guesswork and mysterious cookie errors.  

And if you ever see `Cookies can only be modified from a Server Action` â€” well, now you know why. ğŸ˜‰

---